#!/usr/bin/env node
import fs from "fs-extra";
import { StatementStructures, StructureKind, EnumMemberStructure, Project } from "ts-morph";
import path from "path";
import {v4 as uuidv4 } from "uuid";
import yargs from "yargs";

const cli = yargs
	.option("type", {
		alias: "o",
		describe: "Output Type",
		choices: ["uuid", "text"],
		default: "uuid"
	}).option("name", {
		alias: "n",
		describe: "The name of the generated enum",
		type: "string",
		default: "RemoteId",
	}).option("source", {
		alias: "s",
		describe: "The source directory",
		type: "string",
		default: process.cwd()
	}).option("recursive", {
		alias: "r",
		type: "boolean",
		default: true,
	}).argv;

interface RemoteIdFile {
	Name?: string;
	IDs: Array<string>;
}

function isRemoteIdProjectFile(data: {}): data is RemoteIdFile {
	return "IDs" in data && Array.isArray(data["IDs"]);
}

function generateNameForKey(key: string, type: string) {
	if (type === "uuid") {
		return uuidv4(); 
	} else {
		return key;
	}
}

function jsonToIdTS(contents: string) {
	const data = JSON.parse(contents);
	const statements = new Array<StatementStructures>();
	if (isRemoteIdProjectFile(data)) {
		const enumMembers = new Array<EnumMemberStructure>();

		for (const value of data.IDs) {
			if (typeof value === "string") {
				enumMembers.push({
					kind: StructureKind.EnumMember,
					name: value,
					value: generateNameForKey(value, cli.type),
				});
			}
		}

		statements.push({
			kind: StructureKind.Enum,
			isExported: true,
			isConst: true,
			name: data.Name ?? cli.name,
			members: enumMembers,
		});

		return statements;
	} else {
		console.warn("invalid format for " + contents);
	}
}

const EXT = ".id.json";

const project = new Project({
	compilerOptions: {
		declaration: true,
	}
});

function emitOutput(files: string[], relativeTo: string) {

	
	for (const file of files) {
		const filePath = path.resolve(relativeTo, file);
		
		const r = fs.statSync(filePath);
		if (r.isFile()) {
			if (file.endsWith(EXT)) {
				const structure = jsonToIdTS(fs.readFileSync(filePath).toString());
				if (structure) {


					const newFile = path.join(path.dirname(filePath), path.basename(filePath, EXT) + ".d.ts")
					project.createSourceFile(newFile, {
						statements: structure,
						leadingTrivia: "/* Generated by RbxNetIdGen */",
					}, {overwrite: true})
					console.log("compile", filePath, "->", path.basename(filePath, EXT) + ".d.ts");
					
				}
			}
		} else if (r.isDirectory() && cli.recursive) {
			emitOutput(fs.readdirSync(filePath), filePath);
		}
	}
}

fs.readdir(cli.source).then(files => {
	emitOutput(files, cli.source);
	project.save();
})